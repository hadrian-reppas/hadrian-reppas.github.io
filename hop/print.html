<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Hop Programming Language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">3.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="built-in-functions.html"><strong aria-hidden="true">4.</strong> Built-in Functions</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">5.</strong> Structs</a></li><li class="chapter-item expanded "><a href="globals.html"><strong aria-hidden="true">6.</strong> Globals</a></li><li class="chapter-item expanded "><a href="imports.html"><strong aria-hidden="true">7.</strong> Imports</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">8.</strong> Generics</a></li><li class="chapter-item expanded "><a href="let-statements.html"><strong aria-hidden="true">9.</strong> Let Statements</a></li><li class="chapter-item expanded "><a href="expressions.html"><strong aria-hidden="true">10.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="alloc.html"><strong aria-hidden="true">11.</strong> Allocations</a></li><li class="chapter-item expanded "><a href="assert-and-abort.html"><strong aria-hidden="true">12.</strong> Assertions</a></li><li class="chapter-item expanded "><a href="function-pointers.html"><strong aria-hidden="true">13.</strong> Function Pointers</a></li><li class="chapter-item expanded "><a href="the-standard-library.html"><strong aria-hidden="true">14.</strong> The Standard Library</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">15.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guessing-game.html"><strong aria-hidden="true">15.1.</strong> Guessing Game</a></li><li class="chapter-item expanded "><a href="sorting.html"><strong aria-hidden="true">15.2.</strong> Sorting</a></li><li class="chapter-item expanded "><a href="strings.html"><strong aria-hidden="true">15.3.</strong> Strings</a></li></ol></li><li class="chapter-item expanded "><a href="a-note.html"><strong aria-hidden="true">16.</strong> A Note on Transpilation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hop Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Hop is a statically typed, compiled programming language. Like <a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a>,
Hop is stack-based. Instead of assigning values to variables, values are pushed
and popped from an implicit stack. When called, functions pop their arguments off 
the stack and push their return values back onto it. Let's look at an example.</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>Here is a hello world program in Hop:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-comment">// hello_world.hop</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-string">"Hello, World!"</span> <span class="hljs-title">putlns</span>
}</code></pre>
<p>When this program is run, the string literal <code>&quot;Hello, World!&quot;</code> is pushed onto the
stack. The <code>putlns</code> function then pops the string from the stack and prints it.</p>
<h2 id="running-hop-code"><a class="header" href="#running-hop-code">Running Hop Code</a></h2>
<p>The Hop compiler is called <code>chop</code>. <code>chop</code> transpiles Hop code to C code. It is
invoked like this:</p>
<pre><code class="language-shell">$ chop hello_world.hop
</code></pre>
<p><code>chop</code> produces a file called <code>out.c</code>. The C file can be compiled by any C compiler
and run.</p>
<pre><code class="language-shell">$ clang -o out out.c
$ ./out
Hello, World!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h2>
<p>Hop has 4 built-in types:</p>
<ol>
<li><code>int</code>: a 64 bit, signed integer</li>
<li><code>float</code>: a double-precision floating point number</li>
<li><code>bool</code>: a boolean</li>
<li><code>byte</code>: an 8 bit, unsigned integer</li>
</ol>
<p>Hop also has pointer types like <code>*int</code> and <code>**byte</code>. Hop doesn't have a character type.
Instead, character literal produce integers. Like C, Hop represents strings as null-terminated
sequences of bytes. A string literal produces a <code>*byte</code>:</p>
<pre><code class="language-plaintext hljs">    <span class="hljs-number">2</span>      <span class="hljs-comment">// int</span>
    <span class="hljs-number">1.5</span>    <span class="hljs-comment">// float</span>
    <span class="hljs-string">'A'</span>    <span class="hljs-comment">// int</span>
    <span class="hljs-literal">true</span>   <span class="hljs-comment">// bool</span>
    <span class="hljs-string">b'z'</span>   <span class="hljs-comment">// byte</span>
    <span class="hljs-string">"str"</span>  <span class="hljs-comment">// *byt</span><span class="hljs-title">e</span></code></pre>
<h2 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h2>
<p>Functions are defined with the <code>fn</code> keyword followed by a name. Then comes the parameter types,
an arrow, and the return types. The arrow can be skipped if the function doesn't return anything.</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">increment</span> <span class="hljs-built_in">int</span> -> <span class="hljs-built_in">int</span> { ... }   <span class="hljs-comment">// takes an int and returns an int</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">print</span> <span class="hljs-built_in">int</span> { ... }              <span class="hljs-comment">// takes an int and returns nothing</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">print</span> <span class="hljs-built_in">int</span> -> { ... }           <span class="hljs-comment">// same as above, but with the optional arrow</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">constants</span> -> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> { ... } <span class="hljs-comment">// takes nothing and returns two byte</span><span class="hljs-title">s</span></code></pre>
<h2 id="function-bodies"><a class="header" href="#function-bodies">Function Bodies</a></h2>
<p>At the start of the function body, the stack contains the arguments that the function was
called with. At the end of the function body, the stack should contain the return values.
Here is a function that takes three <code>int</code>s and adds them together:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_ints</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span> -> <span class="hljs-built_in">int</span> {
    + +
}</code></pre>
<p>The <code>+</code> function adds 2 <code>int</code>s. It's signature is <code>int int -&gt; int</code>, so each time it is called,
it pops two <code>int</code>s off the stack and pushes their sum onto the stack. Here is an annotated
version with what the stack looks like at each point when <code>add_ints</code> is called with <code>1</code>,
<code>2</code>, and <code>3</code> as arguments:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_ints</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span> -> <span class="hljs-built_in">int</span> { <span class="hljs-comment">// start:   [1, 2, 3]</span>
    +                            <span class="hljs-comment">// after +: [1, 5]</span>
    +                            <span class="hljs-comment">// after +: [6]</span>
}</code></pre>
<p>Notice that at the end of the function, the stack contains a single <code>int</code> which matches the
function's declared return type.</p>
<h2 id="function-overloading"><a class="header" href="#function-overloading">Function Overloading</a></h2>
<p>Hop supports function overloading. This means multiple functions can have the same name as long
as their parameters don't overlap. Each time an overloaded function is called, the compiler
looks at the stack and determines which version of the function should be called. Here is an example:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">overloaded</span> <span class="hljs-built_in">int</span> {
    ~
    <span class="hljs-string">"int on top of the stack!"</span> <span class="hljs-title">putlns</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">overloaded</span> <span class="hljs-built_in">float</span> {
    ~
    <span class="hljs-string">"float on top of the stack!"</span> <span class="hljs-title">putlns</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-number">1</span>   <span class="hljs-title">overloaded</span> <span class="hljs-comment">// int version</span>
    <span class="hljs-number">1.5</span> <span class="hljs-title">overloaded</span> <span class="hljs-comment">// float version</span>
}</code></pre>
<p>When run, this program produces the following output:</p>
<pre><code class="language-shell">int on top of the stack!
float on top of the stack!
</code></pre>
<p>Two overloaded functions overlap if there exists a stack where calling them would be ambiguous.
For example, consider these two overloaded functions:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">overloaded</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">byte</span> { ... }
<span class="hljs-keyword">fn</span> <span class="hljs-title">overloaded</span> <span class="hljs-built_in">byte</span> { ... }

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-number">1</span> <span class="hljs-string">b'a'</span>     <span class="hljs-comment">// stack is [int, byte]</span>
    <span class="hljs-title">overloaded</span> <span class="hljs-comment">// ambiguous! Which version should be called?</span>
}</code></pre>
<p>If we try to compile this code, <code>chop</code> gives us this error message:</p>
<pre><code class="language-shell">$ chop bad_overload.hop
type error: signature conflicts with a previous definition
 --&gt; bad_overload.hop:2:4
  |
2 | fn overloaded byte { ... }
  |    ^^^^^^^^^^

note: previous definition is here
 --&gt; bad_overload.hop:1:4
  |
1 | fn overloaded int byte { ... }
  |    ^^^^^^^^^^

note: 'overloaded' has signature [int, byte] -&gt; []
</code></pre>
<p>Checking for overlap with primitive types is simple. The compiler just checks
if one parameter list is a suffix of another. But things get more complicated
when checking <a href="./generics.html">generic functions</a>.</p>
<h2 id="the-main-function"><a class="header" href="#the-main-function">The <code>main</code> Function</a></h2>
<p>Every Hop program must have exactly one <code>main</code> function with one of the following
signatures:</p>
<ul>
<li><code>fn main</code></li>
<li><code>fn main -&gt; int</code></li>
<li><code>fn main int **byte</code></li>
<li><code>fn main int **byte -&gt; int</code></li>
</ul>
<p>If <code>main</code> returns an <code>int</code>, that value is the exit code of the process. If <code>main</code> does
not return an <code>int</code>, the exit code is 0. If <code>main</code> takes an <code>int</code> and <code>**byte</code>, those
values correspond to argc and argv in a C program's <code>main</code> function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Hop has 3 control flow statements: if, while, and for.</p>
<h2 id="ifelse-statements"><a class="header" href="#ifelse-statements">If/Else Statements</a></h2>
<p>An if statement requires a <code>bool</code> on the top of the stack. If the value on
the top of the stack is true, the if block is executed. Otherwise, the optional
else block is executed. Here is an example:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_age</span> <span class="hljs-built_in">int</span> {
    <span class="hljs-keyword">if</span> <span class="hljs-number">21</span> < {
        <span class="hljs-string">"under 21"</span> <span class="hljs-title">putlns</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-string">"21 or over"</span> <span class="hljs-title">putlns</span>
    }
}</code></pre>
<p>This function takes an <code>int</code> and compares it with 21. If it's less than 21, the
if block is executed and prints &quot;under 21.&quot; Otherwise, the else block is executed
and prints &quot;21 or over.&quot; We can rewrite the function to do nothing if the input
is 21 or over:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_age</span> <span class="hljs-built_in">int</span> {
    <span class="hljs-keyword">if</span> <span class="hljs-number">21</span> < {
        <span class="hljs-string">"under 21"</span> <span class="hljs-title">putlns</span>
    }
}</code></pre>
<p>Now consider this code:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-comment">// bad_if.hop</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">return_1_if_true</span> <span class="hljs-built_in">bool</span> -> <span class="hljs-built_in">int</span> {
    <span class="hljs-keyword">if</span> {
        <span class="hljs-number">1</span>
    } <span class="hljs-comment">// error here</span>
}</code></pre>
<p>If we try to compile this, we get the following error message:</p>
<pre><code class="language-shell">$ chop bad_if.hop
type error: stack does not match the stack before if block
 --&gt; bad_if.hop:4:5
  |
4 |     } // error here
  |     ^

note: before if block, stack is [] (bad_if.hop:2:8)
note: after if block, stack is [int] (bad_if.hop:4:5)
</code></pre>
<p>We cannot compile this code because the stack depends on which path the program
takes. At the start of the function, the stack contains the <code>bool</code> that the function
was called with. The if statement pops the <code>bool</code> off the top of the stack. If it is
true, the if block executes and pushes 1 onto the stack. So after the if block, the 
stack is <code>[int]</code>. But if the input is false, the if block does not execute and the
stack stays empty (stack is <code>[]</code>). This is not allowed in Hop. The types on the
stack cannot depend on the path that the program takes. These two examples are okay:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">okay_if</span> <span class="hljs-built_in">bool</span> {
    <span class="hljs-keyword">if</span> {
        <span class="hljs-string">"Yes!"</span> <span class="hljs-title">putlns</span> <span class="hljs-comment">// *byte is pushed and then popped</span>
    } <span class="hljs-comment">// so stack is empty here</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">okay_if_else</span> <span class="hljs-built_in">bool</span> {
    <span class="hljs-keyword">if</span> {
        <span class="hljs-string">"Yes!"</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-string">"No."</span>
    } <span class="hljs-comment">// *byte is pushed in both cases</span>
    <span class="hljs-title">putlns</span>
}</code></pre>
<h2 id="while-statements"><a class="header" href="#while-statements">While Statements</a></h2>
<p>A while statement also pops a <code>bool</code> from the top of the stack. The block continues
to execute as long as the <code>bool</code> is true. Here is an example that prints the numbers
from 1 to 5:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-comment">// count.hop</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-number">1</span>               <span class="hljs-comment">// push 1 onto the stack</span>
    <span class="hljs-keyword">while</span> . <span class="hljs-number">5</span> <= {  <span class="hljs-comment">// check if the int is still less than 5</span>
        . <span class="hljs-title">putln</span>     <span class="hljs-comment">// print the int</span>
        <span class="hljs-number">1</span> +         <span class="hljs-comment">// add 1 to the int</span>
    }
    ~
}</code></pre>
<p>Ignore the <code>.</code> and <code>~</code> functions for now. They are explained in the <a href="./built-in-functions.html">built-in functions chapter</a>. When run, this is the program's
output:</p>
<pre><code class="language-shell">$ chop count.hop
$ clang -o out out.c
$ ./out
1
2
3
4
5
</code></pre>
<p>Again, the stack after the while block must match the stack before the while
block. So this program is invalid:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-comment">// bad_while.hop</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> {
        <span class="hljs-number">1</span>
    } <span class="hljs-comment">// error here</span>
}</code></pre>
<p>When compiled, <code>chop</code> outputs this error message:</p>
<pre><code class="language-shell">$ chop bad_while.hop
type error: stack does not match the stack before while block
 --&gt; bad_while.hop:5:5
  |
5 |     } // error here
  |     ^

note: before while block, stack is [] (bad_while.hop:2:16)
note: after while block, stack is [int] (bad_while.hop:5:5)
</code></pre>
<h2 id="for-statements"><a class="header" href="#for-statements">For Statements</a></h2>
<p>For statements iterate from a lower bound to an upper bound. At the start
of each iteration, the <code>int</code> is pushed into the stack. Here is an alternate
Implementation of our counting program that uses a for loop:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-comment">// count.hop</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">6</span> {  <span class="hljs-comment">// int pushed onto the stack</span>
        <span class="hljs-title">putln</span>     <span class="hljs-comment">// int printed. stack is empty</span>
    }
}</code></pre>
<p>Notice that the upper bounds is 6 because the iteration does not include the
upper bound. When run, this program outputs the following:</p>
<pre><code class="language-shell">$ chop count.hop
$ clang -o out out.c
$ ./out
1
2
3
4
5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-functions"><a class="header" href="#built-in-functions">Built-in Functions</a></h1>
<p>Here is a list of Hop's built-in functions. Because Hop functions can be
overloaded, some of them have multiple signatures. Functions
with brackets after their names are generic. Generic functions are
described in the <a href="./generics.html">generics chapter</a>.</p>
<ul>
<li>
<p><code>.</code> - duplicate a value on the stack</p>
<ul>
<li><code>fn .[T] T -&gt; T T</code></li>
</ul>
</li>
<li>
<p><code>~</code> - pop a value from the stack</p>
<ul>
<li><code>fn ~[T] T</code></li>
</ul>
</li>
<li>
<p><code>@</code> - get a pointer to stack's top value</p>
<ul>
<li><code>fn @[T] T -&gt; T *T</code></li>
</ul>
</li>
<li>
<p><code>put</code> - print a primitive value</p>
<ul>
<li><code>fn put int</code></li>
<li><code>fn put float</code></li>
<li><code>fn put byte</code></li>
<li><code>fn put bool</code></li>
</ul>
</li>
<li>
<p><code>putln</code> - print a primitive value with a newline</p>
<ul>
<li><code>fn putln int</code></li>
<li><code>fn putln float</code></li>
<li><code>fn putln byte</code></li>
<li><code>fn putln bool</code></li>
</ul>
</li>
<li>
<p><code>puts</code> - print a string</p>
<ul>
<li><code>fn puts *byte</code></li>
</ul>
</li>
<li>
<p><code>putlns</code> - print a string with a newline</p>
<ul>
<li><code>fn putlns *byte</code></li>
</ul>
</li>
<li>
<p><code>putc</code> - print a character</p>
<ul>
<li><code>fn putc int</code></li>
</ul>
</li>
<li>
<p><code>putlnc</code> - print a character with a newline</p>
<ul>
<li><code>fn putlnc int</code></li>
</ul>
</li>
<li>
<p><code>putp</code> - print a pointer</p>
<ul>
<li><code>fn putp[T] *T</code></li>
</ul>
</li>
<li>
<p><code>putlnp</code> - print a pointer with a newline</p>
<ul>
<li><code>fn putlnp[T] *T</code></li>
</ul>
</li>
<li>
<p><code>ln</code> - print a newline</p>
<ul>
<li><code>fn ln</code></li>
</ul>
</li>
<li>
<p><code>read</code> - read a pointer</p>
<ul>
<li><code>fn read[T] *T -&gt; T</code></li>
</ul>
</li>
<li>
<p><code>write</code> - write to a pointer</p>
<ul>
<li><code>fn write[T] *T T</code></li>
</ul>
</li>
<li>
<p><code>exit</code> - exit the program with the given exit code</p>
<ul>
<li><code>fn exit int</code></li>
</ul>
</li>
<li>
<p><code>realloc</code> - reallocate an allocated pointer</p>
<ul>
<li><code>fn realloc[T] *T int -&gt; *T</code></li>
</ul>
</li>
<li>
<p><code>free</code> - free an allocated pointer</p>
<ul>
<li><code>fn free[T] *T</code></li>
</ul>
</li>
<li>
<p><code>copy</code> - copy values from one pointer to another</p>
<ul>
<li><code>fn copy[T] let dst: *T src: *T n: int</code></li>
</ul>
</li>
<li>
<p><code>pow</code> - raise one <code>float</code> to the power of another</p>
<ul>
<li><code>fn pow float float -&gt; float</code></li>
</ul>
</li>
<li>
<p><code>random</code> - generate a random <code>float</code> in [0, 1)</p>
<ul>
<li><code>fn random -&gt; float</code></li>
</ul>
</li>
<li>
<p><code>time</code> - get the current time in seconds</p>
<ul>
<li><code>fn time -&gt; float</code></li>
</ul>
</li>
<li>
<p><code>stdin</code> - read a line from stdin into a heap-allocated string (or return
null on failure)</p>
<ul>
<li><code>fn -&gt; *byte</code></li>
</ul>
</li>
<li>
<p><code>to_byte</code> - convert a number to a <code>byte</code></p>
<ul>
<li><code>fn to_byte int -&gt; byte</code></li>
<li><code>fn to_byte float -&gt; byte</code></li>
</ul>
</li>
<li>
<p><code>to_int</code> - convert a number to an <code>int</code></p>
<ul>
<li><code>fn to_int byte -&gt; int</code></li>
<li><code>fn to_int float -&gt; int</code></li>
<li><code>fn to_int[T] *T -&gt; int</code></li>
</ul>
</li>
<li>
<p><code>to_float</code> - convert a number to a <code>float</code></p>
<ul>
<li><code>fn to_float byte -&gt; float</code></li>
<li><code>fn to_float int -&gt; float</code></li>
</ul>
</li>
<li>
<p><code>+</code> - add two numbers</p>
<ul>
<li><code>fn + byte byte -&gt; byte</code></li>
<li><code>fn + byte int -&gt; int</code></li>
<li><code>fn + byte float -&gt; float</code></li>
<li><code>fn + int byte -&gt; int</code></li>
<li><code>fn + int int -&gt; int</code></li>
<li><code>fn + int float -&gt; float</code></li>
<li><code>fn + float byte -&gt; float</code></li>
<li><code>fn + float int -&gt; float</code></li>
<li><code>fn + float float -&gt; float</code></li>
<li><code>fn +[T] *T int -&gt; *T</code></li>
<li><code>fn +[T] int *T -&gt; *T</code></li>
</ul>
</li>
<li>
<p><code>-</code> - subtract two numbers</p>
<ul>
<li><code>fn - byte byte -&gt; byte</code></li>
<li><code>fn - byte int -&gt; int</code></li>
<li><code>fn - byte float -&gt; float</code></li>
<li><code>fn - int byte -&gt; int</code></li>
<li><code>fn - int int -&gt; int</code></li>
<li><code>fn - int float -&gt; float</code></li>
<li><code>fn - float byte -&gt; float</code></li>
<li><code>fn - float int -&gt; float</code></li>
<li><code>fn - float float -&gt; float</code></li>
<li><code>fn -[T] *T int -&gt; *T</code></li>
<li><code>fn -[T] *T *T -&gt; int</code></li>
</ul>
</li>
<li>
<p><code>*</code> - multiply two numbers</p>
<ul>
<li><code>fn * byte byte -&gt; byte</code></li>
<li><code>fn * byte int -&gt; int</code></li>
<li><code>fn * byte float -&gt; float</code></li>
<li><code>fn * int byte -&gt; int</code></li>
<li><code>fn * int int -&gt; int</code></li>
<li><code>fn * int float -&gt; float</code></li>
<li><code>fn * float byte -&gt; float</code></li>
<li><code>fn * float int -&gt; float</code></li>
<li><code>fn * float float -&gt; float</code></li>
</ul>
</li>
<li>
<p><code>/</code> - divide two numbers</p>
<ul>
<li><code>fn / byte byte -&gt; byte</code></li>
<li><code>fn / byte int -&gt; int</code></li>
<li><code>fn / byte float -&gt; float</code></li>
<li><code>fn / int byte -&gt; int</code></li>
<li><code>fn / int int -&gt; int</code></li>
<li><code>fn / int float -&gt; float</code></li>
<li><code>fn / float byte -&gt; float</code></li>
<li><code>fn / float int -&gt; float</code></li>
<li><code>fn / float float -&gt; float</code></li>
</ul>
</li>
<li>
<p><code>%</code> - calculate the modulus of two numbers</p>
<ul>
<li><code>fn % byte byte -&gt; byte</code></li>
<li><code>fn % byte int -&gt; int</code></li>
<li><code>fn % byte float -&gt; float</code></li>
<li><code>fn % int byte -&gt; int</code></li>
<li><code>fn % int int -&gt; int</code></li>
<li><code>fn % int float -&gt; float</code></li>
<li><code>fn % float byte -&gt; float</code></li>
<li><code>fn % float int -&gt; float</code></li>
<li><code>fn % float float -&gt; float</code></li>
</ul>
</li>
<li>
<p><code>&amp;</code> - logical and</p>
<ul>
<li><code>fn &amp; byte byte -&gt; byte</code></li>
<li><code>fn &amp; int int -&gt; int</code></li>
<li><code>fn &amp; bool bool -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>^</code> - logical xor</p>
<ul>
<li><code>fn ^ byte byte -&gt; byte</code></li>
<li><code>fn ^ int int -&gt; int</code></li>
<li><code>fn ^ bool bool -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>|</code> - logical or</p>
<ul>
<li><code>fn | byte byte -&gt; byte</code></li>
<li><code>fn | int int -&gt; int</code></li>
<li><code>fn | bool bool -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>&lt;&lt;</code> - bit shift left</p>
<ul>
<li><code>fn &lt;&lt; byte byte -&gt; byte</code></li>
<li><code>fn &lt;&lt; byte int -&gt; byte</code></li>
<li><code>fn &lt;&lt; int byte -&gt; int</code></li>
<li><code>fn &lt;&lt; int int -&gt; int</code></li>
</ul>
</li>
<li>
<p><code>&gt;&gt;</code> - bit shift right</p>
<ul>
<li><code>fn &gt;&gt; byte byte -&gt; byte</code></li>
<li><code>fn &gt;&gt; byte int -&gt; byte</code></li>
<li><code>fn &gt;&gt; int byte -&gt; int</code></li>
<li><code>fn &gt;&gt; int int -&gt; int</code></li>
</ul>
</li>
<li>
<p><code>==</code> - check if two numbers are equal</p>
<ul>
<li><code>fn == byte byte -&gt; bool</code></li>
<li><code>fn == byte int -&gt; bool</code></li>
<li><code>fn == byte float -&gt; bool</code></li>
<li><code>fn == int byte -&gt; bool</code></li>
<li><code>fn == int int -&gt; bool</code></li>
<li><code>fn == int float -&gt; bool</code></li>
<li><code>fn == float byte -&gt; bool</code></li>
<li><code>fn == float int -&gt; bool</code></li>
<li><code>fn == float float -&gt; bool</code></li>
<li><code>fn ==[T] *T *T -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>!=</code> - check if two numbers are not equal</p>
<ul>
<li><code>fn != byte byte -&gt; bool</code></li>
<li><code>fn != byte int -&gt; bool</code></li>
<li><code>fn != byte float -&gt; bool</code></li>
<li><code>fn != int byte -&gt; bool</code></li>
<li><code>fn != int int -&gt; bool</code></li>
<li><code>fn != int float -&gt; bool</code></li>
<li><code>fn != float byte -&gt; bool</code></li>
<li><code>fn != float int -&gt; bool</code></li>
<li><code>fn != float float -&gt; bool</code></li>
<li><code>fn !=[T] *T *T -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>&lt;</code> - compare two numbers</p>
<ul>
<li><code>fn &lt; byte byte -&gt; bool</code></li>
<li><code>fn &lt; byte int -&gt; bool</code></li>
<li><code>fn &lt; byte float -&gt; bool</code></li>
<li><code>fn &lt; int byte -&gt; bool</code></li>
<li><code>fn &lt; int int -&gt; bool</code></li>
<li><code>fn &lt; int float -&gt; bool</code></li>
<li><code>fn &lt; float byte -&gt; bool</code></li>
<li><code>fn &lt; float int -&gt; bool</code></li>
<li><code>fn &lt; float float -&gt; bool</code></li>
<li><code>fn &lt;[T] *T *T -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>&lt;=</code> - compare two numbers</p>
<ul>
<li><code>fn &lt;= byte byte -&gt; bool</code></li>
<li><code>fn &lt;= byte int -&gt; bool</code></li>
<li><code>fn &lt;= byte float -&gt; bool</code></li>
<li><code>fn &lt;= int byte -&gt; bool</code></li>
<li><code>fn &lt;= int int -&gt; bool</code></li>
<li><code>fn &lt;= int float -&gt; bool</code></li>
<li><code>fn &lt;= float byte -&gt; bool</code></li>
<li><code>fn &lt;= float int -&gt; bool</code></li>
<li><code>fn &lt;= float float -&gt; bool</code></li>
<li><code>fn &lt;=[T] *T *T -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>&gt;</code> - compare two numbers</p>
<ul>
<li><code>fn &gt; byte byte -&gt; bool</code></li>
<li><code>fn &gt; byte int -&gt; bool</code></li>
<li><code>fn &gt; byte float -&gt; bool</code></li>
<li><code>fn &gt; int byte -&gt; bool</code></li>
<li><code>fn &gt; int int -&gt; bool</code></li>
<li><code>fn &gt; int float -&gt; bool</code></li>
<li><code>fn &gt; float byte -&gt; bool</code></li>
<li><code>fn &gt; float int -&gt; bool</code></li>
<li><code>fn &gt; float float -&gt; bool</code></li>
<li><code>fn &gt;[T] *T *T -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>&gt;=</code> - compare two numbers</p>
<ul>
<li><code>fn &gt;= byte byte -&gt; bool</code></li>
<li><code>fn &gt;= byte int -&gt; bool</code></li>
<li><code>fn &gt;= byte float -&gt; bool</code></li>
<li><code>fn &gt;= int byte -&gt; bool</code></li>
<li><code>fn &gt;= int int -&gt; bool</code></li>
<li><code>fn &gt;= int float -&gt; bool</code></li>
<li><code>fn &gt;= float byte -&gt; bool</code></li>
<li><code>fn &gt;= float int -&gt; bool</code></li>
<li><code>fn &gt;= float float -&gt; bool</code></li>
<li><code>fn &gt;=[T] *T *T -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>!</code> - logical not</p>
<ul>
<li><code>fn ! bool -&gt; bool</code></li>
<li><code>fn ! byte -&gt; byte</code></li>
<li><code>fn ! int -&gt; int</code></li>
</ul>
</li>
<li>
<p><code>neg</code> - negate a number</p>
<ul>
<li><code>fn neg int -&gt; int</code></li>
<li><code>fn neg float -&gt; float</code></li>
</ul>
</li>
<li>
<p><code>strcmp</code> - compare 2 strings</p>
<ul>
<li><code>fn strcmp *byte *byte -&gt; int</code></li>
</ul>
</li>
<li>
<p><code>streq</code> - check if 2 strings are equal</p>
<ul>
<li><code>fn streq *byte *byte -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>strcpy</code> - copy a string from one allocation to another</p>
<ul>
<li><code>fn strcpy let dst: *byte src: *byte</code></li>
</ul>
</li>
<li>
<p><code>strlen</code> - find a string's length</p>
<ul>
<li><code>fn strlen *byte -&gt; int</code></li>
</ul>
</li>
<li>
<p><code>read_file</code> - read a file into a heap-allocated string (or return
null on failure)</p>
<ul>
<li><code>fn read_file *byte -&gt; *byte</code></li>
</ul>
</li>
<li>
<p><code>write_to_file</code> - write a string to a file (and return true on success)</p>
<ul>
<li><code>fn write_to_file let text: *byte file_path: *byte -&gt; bool</code></li>
</ul>
</li>
<li>
<p><code>append_to_file</code> - append a string to a file (and return true on success)</p>
<ul>
<li><code>fn append_to_file let text: *byte file_path: *byte -&gt; bool</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Structs can be defined with the <code>struct</code> keyword. Here is how you might define
an array of <code>float</code>s:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">struct</span> <span class="hljs-title">FloatArray</span> {
    <span class="hljs-title">ptr</span>: *<span class="hljs-built_in">float</span>
    <span class="hljs-title">len</span>: <span class="hljs-built_in">int</span>
}</code></pre>
<p>When the Hop compiler encounters this struct definition, it autogenerates some
functions. First, it creates a constructor. The constructor has the same name as
the struct. It takes in each of the struct's members as parameters and returns
an instance of the struct:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">FloatArray</span> *<span class="hljs-built_in">float</span> <span class="hljs-built_in">int</span> -> <span class="hljs-title">FloatArray</span> { ... }</code></pre>
<p>The Hop compiler also generates 4 member accessors for each member for the <code>ptr</code>
member in our <code>FloatArray</code>, the compiler generates these four functions:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> .<span class="hljs-title">ptr</span> <span class="hljs-title">FloatArray</span> -> *<span class="hljs-built_in">float</span> { ... }
<span class="hljs-keyword">fn</span> ..<span class="hljs-title">ptr</span> <span class="hljs-title">FloatArray</span> -> <span class="hljs-title">FloatArray</span> *<span class="hljs-built_in">float</span> { ... }
<span class="hljs-keyword">fn</span> .<span class="hljs-title">ptr</span> *<span class="hljs-title">FloatArray</span> -> **<span class="hljs-built_in">float</span> { ... }
<span class="hljs-keyword">fn</span> ..<span class="hljs-title">ptr</span> *<span class="hljs-title">FloatArray</span> -> *<span class="hljs-title">FloatArray</span> **<span class="hljs-built_in">float</span> { ... }</code></pre>
<p>The single dot functions consume an instance of a <code>FloatArray</code> and return the <code>ptr</code>
member. The double dot functions return the <code>ptr</code> member but do not consume the
<code>FloatArray</code> from the stack. The compiler also provides overloaded functions that take
a pointer to the <code>FloatArray</code> and return a pointer to the <code>ptr</code> member. The compiler
generates the same 4 functions for the <code>len</code> member:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> .<span class="hljs-title">len</span> <span class="hljs-title">FloatArray</span> -> <span class="hljs-built_in">int</span> { ... }
<span class="hljs-keyword">fn</span> ..<span class="hljs-title">len</span> <span class="hljs-title">FloatArray</span> -> <span class="hljs-title">FloatArray</span> <span class="hljs-built_in">int</span> { ... }
<span class="hljs-keyword">fn</span> .<span class="hljs-title">len</span> *<span class="hljs-title">FloatArray</span> -> *<span class="hljs-built_in">int</span> { ... }
<span class="hljs-keyword">fn</span> ..<span class="hljs-title">len</span> *<span class="hljs-title">FloatArray</span> -> *<span class="hljs-title">FloatArray</span> *<span class="hljs-built_in">int</span> { ... }</code></pre>
<p>Here is a small program that uses the <code>FloatArray</code> struct:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">struct</span> <span class="hljs-title">FloatArray</span> {
    <span class="hljs-title">ptr</span>: *<span class="hljs-built_in">float</span>
    <span class="hljs-title">len</span>: <span class="hljs-built_in">int</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">print_last_float</span> <span class="hljs-title">FloatArray</span> {
    ..<span class="hljs-title">len</span>          <span class="hljs-comment">// get the length</span>
    <span class="hljs-keyword">let</span> <span class="hljs-title">len</span> {
       .<span class="hljs-title">ptr</span>        <span class="hljs-comment">// get a pointer to the first element</span>
       <span class="hljs-title">len</span> + <span class="hljs-number">1</span> -   <span class="hljs-comment">// get a pointer to the last element</span>
       <span class="hljs-title">read</span> <span class="hljs-title">putln</span>  <span class="hljs-comment">// print the value</span>
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-number">5</span> <span class="hljs-keyword">zalloc_arr</span>[<span class="hljs-built_in">float</span>] <span class="hljs-comment">// allocate room for 5 floats (stack is [*float])</span>
    <span class="hljs-number">5</span>                   <span class="hljs-comment">// push the len               (stack is [*float, int])</span>
    <span class="hljs-title">FloatArray</span>          <span class="hljs-comment">// construct the FloatArray   (Stack is [FloatArray])</span>
    <span class="hljs-title">print_last_float</span>    <span class="hljs-comment">// print the last float</span>
}</code></pre>
<p>The <code>let</code> keyword is described <a href="./let-statements.html">here</a> and the <code>zalloc_arr</code>
keyword is described <a href="./alloc.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="globals"><a class="header" href="#globals">Globals</a></h1>
<p>Globals can be defined with the <code>global</code> keyword. Globals must have an explicit
type and can optionally have an initializer in curly braces. Here are some
examples:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">global</span> <span class="hljs-title">count</span>: <span class="hljs-built_in">int</span>
<span class="hljs-keyword">global</span> <span class="hljs-title">flag</span>: <span class="hljs-built_in">bool</span> { <span class="hljs-literal">true</span> }
<span class="hljs-keyword">global</span> <span class="hljs-title">epsilon</span>: <span class="hljs-built_in">float</span> { <span class="hljs-number">1.0</span> <span class="hljs-number">10000.0</span> / }</code></pre>
<p>Each global declaration autogenerates 3 functions. For the <code>count</code> global above
with type <code>int</code>, these three functions are generated:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">count</span> -> <span class="hljs-built_in">int</span> { ... }
<span class="hljs-keyword">fn</span> <span class="hljs-title">write_count</span> <span class="hljs-built_in">int</span> { ... }
<span class="hljs-keyword">fn</span> <span class="hljs-title">count_ptr</span> -> *<span class="hljs-built_in">int</span> { ... }</code></pre>
<p>The <code>count</code> function returns the value of the global. The <code>write_count</code>
function takes an <code>int</code> and updates the global. The <code>count_ptr</code> function returns
a pointer to the global.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Here is an example:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">global</span> <span class="hljs-title">count</span>: <span class="hljs-built_in">int</span> { <span class="hljs-number">1</span> <span class="hljs-number">2</span> + } <span class="hljs-comment">// count initialized to 3</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title">increment_by_value</span> {
    <span class="hljs-title">count</span>       <span class="hljs-comment">// get the old value</span>
    <span class="hljs-number">1</span> +         <span class="hljs-comment">// add 1</span>
    <span class="hljs-title">write_count</span> <span class="hljs-comment">// write the new value</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">increment_by_ptr</span> {
    <span class="hljs-title">count_ptr</span>   <span class="hljs-comment">// get a pointer to count</span>
    . <span class="hljs-title">read</span> <span class="hljs-number">1</span> +  <span class="hljs-comment">// increment the value (stack is [*int, int])</span>
    <span class="hljs-title">write</span>       <span class="hljs-comment">// write the new value to the pointer</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-title">increment_by_value</span> <span class="hljs-comment">// count is now 4</span>
    <span class="hljs-title">increment_by_ptr</span>   <span class="hljs-comment">// count is now 5</span>

    <span class="hljs-title">count</span> <span class="hljs-title">putln</span>        <span class="hljs-comment">// prints 5</span>
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imports"><a class="header" href="#imports">Imports</a></h1>
<p>Functions and structs can be imported from other files with the <code>import</code>
keyword. Consider this directory layout:</p>
<pre><code>main.hop
hello.hop
helpers
 ├ goodbye.hop
 └ pairs
    └ pair_defs.hop
</code></pre>
<p><code>hello.hop</code> defines the <code>say_hello</code> and <code>hello_again</code> functions, <code>goodbye.hop</code>
defines the <code>say_goodbye</code> function and <code>pair_defs.hop</code> defines the <code>IntPair</code> and
<code>BytePair</code> structs:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">struct</span> <span class="hljs-title">IntPair</span> {
    <span class="hljs-title">a</span>: <span class="hljs-built_in">int</span>
    <span class="hljs-title">b</span>: <span class="hljs-built_in">int</span>
}

<span class="hljs-keyword">struct</span> <span class="hljs-title">BytePair</span> {
    <span class="hljs-title">a</span>: <span class="hljs-built_in">byte</span>
    <span class="hljs-title">b</span>: <span class="hljs-built_in">byte</span>
}</code></pre>
<h2 id="importing-functions"><a class="header" href="#importing-functions">Importing Functions</a></h2>
<p>Let's say we want to call the <code>say_hello</code>, <code>hello_again</code> and <code>say_goodbye</code>
functions in <code>main.hop</code>. We can bring them into scope like this:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-title">hello</span>::{<span class="hljs-title">say_hello</span> <span class="hljs-title">hello_again</span>}
<span class="hljs-keyword">import</span> <span class="hljs-title">helpers</span>::<span class="hljs-title">goodbye</span>::{<span class="hljs-title">say_goodbye</span>}

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-title">say_hello</span>
    <span class="hljs-title">hello_again</span>
    <span class="hljs-title">say_goodbye</span>
}</code></pre>
<p>When <code>chop</code> encounters an import statement, it goes and parses the appropriate
file. For the first import, <code>chop</code> looks for a file called <code>hello.hop</code> in the
same directory as the current file (<code>main.hop</code>). It then parses it and bring the
<code>say_hello</code> and <code>hello_again</code> functions into scope. When <code>chop</code> sees the second
import, it looks for the file <code>helpers/goodbye.hop</code> and brings the <code>say_goodbye</code>
function into scope.</p>
<h2 id="importing-overloaded-functions"><a class="header" href="#importing-overloaded-functions">Importing Overloaded Functions</a></h2>
<p>You can import multiple functions with the same name as long as their parameters
do not overlap. If two functions with the same name have overlaping signatures,
<code>chop</code> will emit an error message. Here is an example of overlaping imports:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-title">a</span>::{<span class="hljs-title">overloaded</span>}
<span class="hljs-keyword">import</span> <span class="hljs-title">b</span>::{<span class="hljs-title">overloaded</span>}</code></pre>
<p><code>chop</code> emits this error message:</p>
<pre><code class="language-shell">$ chop main.hop
import error: imported function 'overloaded' overlaps with a previous import
 --&gt; main.hop:2:12
  |
2 | import b::{overloaded}
  |            ^^^^^^^^^^

note: 'overloaded' is imported here
 --&gt; main.hop:1:12
  |
1 | import a::{overloaded}
  |            ^^^^^^^^^^

note: previously imported signature is [int] -&gt; [int]
note: new signature is [int] -&gt; [int]
</code></pre>
<p>Imported functions can also conflict with functions defined in the current file.
For example, this code contains an overlapping import:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">overloaded</span> <span class="hljs-built_in">int</span> -> <span class="hljs-built_in">int</span> {}
<span class="hljs-keyword">import</span> <span class="hljs-title">a</span>::{<span class="hljs-title">overloaded</span>}</code></pre>
<p><code>chop</code> emits the following message:</p>
<pre><code class="language-shell">$ chop main.hop
import error: imported function conflicts with a previously defined function
 --&gt; main.hop:2:12
  |
2 | import b::{overloaded}
  |            ^^^^^^^^^^

note: 'overloaded' is defined here
 --&gt; main.hop:1:4
  |
1 | fn overloaded int -&gt; int {}
  |    ^^^^^^^^^^

note: definition of 'overloaded' has signature [int] -&gt; [int]
note: imported function 'overloaded' has signature [int] -&gt; [int]
</code></pre>
<h2 id="importing-structs"><a class="header" href="#importing-structs">Importing Structs</a></h2>
<p>Structs can be imported with the <code>import</code> and <code>struct</code> keywords. If we want
to import the <code>IntPair</code> and <code>BytePair</code> structs, we can do this:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">helpers</span>::<span class="hljs-title">pairs</span>::<span class="hljs-title">pair_defs</span>::{<span class="hljs-title">IntPair</span> <span class="hljs-title">BytePair</span>}

<span class="hljs-keyword">fn</span> <span class="hljs-title">consume_int_pair</span> <span class="hljs-title">IntPair</span> { ~ }

<span class="hljs-keyword">fn</span> <span class="hljs-title">consume_byte_pair</span> <span class="hljs-title">BytePair</span> { ~ }</code></pre>
<p>Note that the <code>import struct</code> statement only imports the struct name (for use
in function signatures). The struct constructor and member accessors must be
imported separately like any other function:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">helpers</span>::<span class="hljs-title">pairs</span>::<span class="hljs-title">pair_defs</span>::{<span class="hljs-title">IntPair</span>}
<span class="hljs-keyword">import</span> <span class="hljs-title">helper</span>::<span class="hljs-title">pairs</span>::<span class="hljs-title">pair_defs</span>::{<span class="hljs-title">IntPair</span>}

<span class="hljs-keyword">fn</span> <span class="hljs-title">consume_pair</span> <span class="hljs-title">IntPair</span> { ~ }

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-title">IntPair</span>
    <span class="hljs-title">consume_pair</span>
}</code></pre>
<h2 id="importing-modules"><a class="header" href="#importing-modules">Importing Modules</a></h2>
<p>Sometimes it's easier to import a whole module. You can do this by not including
curly braces in the import statement. Then you can refer to imported functions
and types with the <code>::</code> qualified syntax:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-title">helpers</span>::<span class="hljs-title">pairs</span>::<span class="hljs-title">pair_defs</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title">consume_pair</span> <span class="hljs-title">pair_defs</span>::<span class="hljs-title">IntPair</span> { ~ }

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-title">pair_defs</span>::<span class="hljs-title">IntPair</span>
    <span class="hljs-title">consume_pair</span>
}</code></pre>
<p>Unlike other languages, you cannot qualify a name more than once. For example,
you cannot do this because the compiler does not understand the doubly qualified
name <code>pairs::pair_defs::IntPair</code>:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-title">helpers</span>::<span class="hljs-title">pairs</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title">consume_pair</span> <span class="hljs-title">pairs</span>::<span class="hljs-title">pair_defs</span>::<span class="hljs-title">IntPair</span> { ~ }</code></pre>
<h2 id="standard-library-imports"><a class="header" href="#standard-library-imports">Standard Library Imports</a></h2>
<p>Imports that begin with <code>std::</code> get looked up in the Hop standard library. More
about the standard library can be found in <a href="./the-standard-library.html">the standard library chapter</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Like most modern languages, Hop supports generic functions and structs. Generic
parameters are specified in square brackets. </p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h2>
<p>As an example, consider the generic
function <code>swap</code> from <code>std::prelude</code>. <code>swap</code> has the following signature:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">swap</span>[<span class="hljs-title">T</span> <span class="hljs-title">U</span>] <span class="hljs-title">T</span> <span class="hljs-title">U</span> -> <span class="hljs-title">U</span> <span class="hljs-title">T</span> { ... }</code></pre>
<p>For some type <code>T</code> and some type <code>U</code>, it takes a value of type <code>T</code> and a value
of type <code>U</code> and returns them in the opposite order. Here are some example uses:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-literal">true</span> <span class="hljs-number">1</span>       <span class="hljs-comment">// stack is [bool, int]</span>
    <span class="hljs-title">swap</span>         <span class="hljs-comment">// T is bool and U is int (stack is now [int, bool])</span>
    <span class="hljs-title">putln</span> <span class="hljs-title">putln</span>  <span class="hljs-comment">// prints true and then 1</span>

    <span class="hljs-string">"s"</span> <span class="hljs-number">1.0</span>      <span class="hljs-comment">// stack is [*byte, float]</span>
    <span class="hljs-title">swap</span>         <span class="hljs-comment">// T is *byte and U is float (stack is now [float, *byte])</span>
    <span class="hljs-title">putlns</span> <span class="hljs-title">putln</span> <span class="hljs-comment">// prints s and then 1.0</span>
}</code></pre>
<p>Notice that a single function can be called with different types. Each time <code>swap</code>
is called, the compiler looks at the stack and figures out the type of <code>T</code> and <code>U</code>.
Consider this other example:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">swap</span>[<span class="hljs-title">T</span>] <span class="hljs-title">T</span> <span class="hljs-title">T</span> -> <span class="hljs-title">T</span> <span class="hljs-title">T</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-title">a</span> <span class="hljs-title">b</span> { <span class="hljs-title">b</span> <span class="hljs-title">a</span> }
}</code></pre>
<p>Ignore the <code>let</code> for now, it is explained in the <a href="./let-statements.html">let statement chapter</a>.
Our new <code>swap</code> function looks like the old one but it only has one generic
parameter (<code>T</code>). This new function can only swap values of the same type:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-title">swap</span>      <span class="hljs-comment">// okay, T is int</span>
    <span class="hljs-title">putln</span> <span class="hljs-title">putln</span>   <span class="hljs-comment">// prints 2 and then 1</span>

    <span class="hljs-literal">true</span> <span class="hljs-number">1</span> <span class="hljs-title">swap</span>   <span class="hljs-comment">// not okay. Should T be int or bool?</span>
}</code></pre>
<p>When we try to compile this code we get this error message:</p>
<pre><code class="language-shell">$ chop generic_swap.hop
type error: no variant of 'swap' matches the stack
 --&gt; generic_swap.hop:9:12
  |
9 |     true 1 swap   // not okay. Should T be int or bool?
  |            ^^^^

note: stack is [bool, int]
note: 'swap' has signature [T0, T0] -&gt; [T0, T0]
</code></pre>
<p>Note that <code>chop</code> uses <code>T0</code> in the signatures instead of <code>T</code>. In error messages,
the compiler uses <code>T0</code>, <code>T1</code>, <code>T2</code>, ... where the index is the position of the
generic parameter. So this function</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">generic</span>[<span class="hljs-title">T</span> <span class="hljs-title">U</span> <span class="hljs-title">V</span>] <span class="hljs-title">T</span> <span class="hljs-title">V</span> <span class="hljs-title">U</span> <span class="hljs-title">V</span> { ... }</code></pre>
<p>really has signature <code>[T0 T2 T1 T2]</code>.</p>
<h2 id="generic-structs"><a class="header" href="#generic-structs">Generic Structs</a></h2>
<p>Generic structs work just like generic functions. Here is an example of how you
might define a dynamic array (or vector) using a generic struct:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span>[<span class="hljs-title">T</span>] {
    <span class="hljs-title">ptr</span>: *<span class="hljs-title">T</span>
    <span class="hljs-title">length</span>: <span class="hljs-built_in">int</span>
    <span class="hljs-title">capacity</span>: <span class="hljs-built_in">int</span>
}</code></pre>
<p>Now any function that takes or returns a <code>Vector</code> must specify the generic
parameter:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-comment">// generic push</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">push</span>[<span class="hljs-title">T</span>] *<span class="hljs-title">Vector</span>[<span class="hljs-title">T</span>] <span class="hljs-title">T</span> { ... }

<span class="hljs-comment">// push an int to a Vector[int] (not generic)</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">push_int</span> *<span class="hljs-title">Vector</span>[<span class="hljs-built_in">int</span>] <span class="hljs-built_in">int</span> { ... }</code></pre>
<p>Generic structs can contain any number of generic parameters:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tuple</span>[<span class="hljs-title">A</span> <span class="hljs-title">B</span> <span class="hljs-title">C</span>] {
    <span class="hljs-title">a</span>: <span class="hljs-title">A</span>
    <span class="hljs-title">b</span>: <span class="hljs-title">B</span>
    <span class="hljs-title">c</span>: <span class="hljs-title">C</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">make_int_tuple</span> -> <span class="hljs-title">Tuple</span>[<span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>] {
    <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-title">Tuple</span>
}</code></pre>
<h1 id="special-functions"><a class="header" href="#special-functions">Special Functions</a></h1>
<p>Normally, generic functions contain all their generic parameters in their
parameter list. This allows the compiler to infer the generic types based on the
stack. Here are some examples:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span>[<span class="hljs-title">T</span>] <span class="hljs-title">T</span> -> <span class="hljs-title">T</span> <span class="hljs-title">T</span> { ... }
<span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span>[<span class="hljs-title">K</span> <span class="hljs-title">V</span>] <span class="hljs-title">HashMap</span>[<span class="hljs-title">K</span> <span class="hljs-title">V</span>] { ... }
<span class="hljs-keyword">fn</span> <span class="hljs-title">baz</span>[<span class="hljs-title">T</span> <span class="hljs-title">U</span>] <span class="hljs-title">T</span> *<span class="hljs-title">T</span> <span class="hljs-title">U</span> *<span class="hljs-title">U</span> { ... }</code></pre>
<p>Functions that do not contain all their generic parameters in their parameter lists
are called 'special'. Special functions can only be called through function
pointers, where their generic types are written explicitly. More about function
pointers can be found in the <a href="./function-pointers.html">function pointers chapter</a>.
Here are some special signatures:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">nothing</span>[<span class="hljs-title">T</span>] { ... }
<span class="hljs-keyword">fn</span> <span class="hljs-title">new_ptr</span>[<span class="hljs-title">T</span>] -> *<span class="hljs-title">T</span> { ... } <span class="hljs-comment">// T only appears in return types</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title">new_vector</span>[<span class="hljs-title">T</span>] -> <span class="hljs-title">Vector</span>[<span class="hljs-title">T</span>] { ... }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-statements"><a class="header" href="#let-statements">Let Statements</a></h1>
<p>When dealing with more than 2 or 3 values, manipulating them on the stack
becomes hard. In these cases, <code>let</code> statements can be helpful. The <code>let</code> keyword
allows you to bind stack variables to names. For example, let's say we want to
define a function that returns the positive root of a quadratic from its
coefficients. It should take \(a\), \(b\) and \(c\) and return</p>
<p>\[\frac{-b + \sqrt{b^2 - 4ac}}{2a}\]</p>
<p>We might do something like this:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-title">std</span>::<span class="hljs-title">prelude</span>::{<span class="hljs-title">swap</span> <span class="hljs-title">under</span> <span class="hljs-title">fourth</span>}

<span class="hljs-keyword">fn</span> <span class="hljs-title">sqrt</span> <span class="hljs-built_in">float</span> -> <span class="hljs-built_in">float</span> { <span class="hljs-number">0.5</span> <span class="hljs-title">pow</span> }

<span class="hljs-keyword">fn</span> <span class="hljs-title">quad_form</span> <span class="hljs-built_in">float</span> <span class="hljs-built_in">float</span> <span class="hljs-built_in">float</span> -> <span class="hljs-built_in">float</span> {
    <span class="hljs-title">under</span> . *
    <span class="hljs-title">swap</span> <span class="hljs-title">fourth</span> * <span class="hljs-number">4</span> * - <span class="hljs-title">sqrt</span>
    <span class="hljs-title">swap</span> <span class="hljs-title">neg</span> +
    <span class="hljs-title">swap</span> <span class="hljs-number">2</span> * /
}</code></pre>
<p>But notice that many of the functions are just manipulating the stack (<code>swap</code>,
<code>under</code>, <code>.</code> and <code>fourth</code>). If we instead use a let statement, we can bind
the function's arguments to <code>a</code>, <code>b</code> and <code>c</code> variables which we can refer to
in our expression:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">quad_form</span> <span class="hljs-built_in">float</span> <span class="hljs-built_in">float</span> <span class="hljs-built_in">float</span> -> <span class="hljs-built_in">float</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-title">a</span> <span class="hljs-title">b</span> <span class="hljs-title">c</span> {
        <span class="hljs-comment">// 3 stack values are bound. stack is now empty</span>
        <span class="hljs-comment">// in this block, we can use a, b and c</span>

        <span class="hljs-title">b</span> <span class="hljs-title">neg</span>
        <span class="hljs-title">b</span> <span class="hljs-title">b</span> * <span class="hljs-number">4</span> <span class="hljs-title">a</span> <span class="hljs-title">c</span> * * -
        <span class="hljs-title">sqrt</span> +
        <span class="hljs-number">2</span> <span class="hljs-title">a</span> * /
    }
}</code></pre>
<p>This looks much nicer.</p>
<h2 id="fn-let-syntax"><a class="header" href="#fn-let-syntax"><code>fn let</code> Syntax</a></h2>
<p>It's quite common to immediately bind a function's arguments with a let
statement. In these cases, you can use the <code>fn let</code> syntax. Here is the
<code>quad_form</code> function using <code>fn let</code>:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">quad_form</span> <span class="hljs-keyword">let</span> <span class="hljs-title">a</span>: <span class="hljs-built_in">float</span> <span class="hljs-title">b</span>: <span class="hljs-built_in">float</span> <span class="hljs-title">c</span>: <span class="hljs-built_in">float</span> -> <span class="hljs-built_in">float</span> {
    <span class="hljs-title">b</span> <span class="hljs-title">neg</span>
    <span class="hljs-title">b</span> <span class="hljs-title">b</span> * <span class="hljs-number">4</span> <span class="hljs-title">a</span> <span class="hljs-title">c</span> * * -
    <span class="hljs-title">sqrt</span> +
    <span class="hljs-number">2</span> <span class="hljs-title">a</span> * /
}</code></pre>
<h2 id="let-for-syntax"><a class="header" href="#let-for-syntax"><code>let for</code> Syntax</a></h2>
<p>It's also common to bind a for loop's iterator variable with a let statement.
In these cases, you can use the <code>let for</code> syntax. Here is a countdown function
using <code>let for</code>:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-title">i</span> <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">10</span> {
        <span class="hljs-number">10</span> <span class="hljs-title">i</span> - <span class="hljs-title">putln</span>
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>Writing everything in <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">reverse Polish notation</a>
is kind of a pain. When doing complicated math, you can use expressions.
Expressions are surrounded by parenthesis. Inside expressions, all the normal
precedence rules apply and functions can be called like C functions. Our
<code>quad_form</code> function now looks like this:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">sqrt</span> <span class="hljs-built_in">float</span> -> <span class="hljs-built_in">float</span> { <span class="hljs-number">0.5</span> <span class="hljs-title">pow</span> }

<span class="hljs-keyword">fn</span> <span class="hljs-title">quad_form</span> <span class="hljs-keyword">let</span> <span class="hljs-title">a</span>: <span class="hljs-built_in">float</span> <span class="hljs-title">b</span>: <span class="hljs-built_in">float</span> <span class="hljs-title">c</span>: <span class="hljs-built_in">float</span> -> <span class="hljs-built_in">float</span> {
    ((-<span class="hljs-title">b</span> + <span class="hljs-title">sqrt</span>(<span class="hljs-title">b</span>*<span class="hljs-title">b</span> - <span class="hljs-number">4</span>*<span class="hljs-title">a</span>*<span class="hljs-title">c</span>))/(<span class="hljs-number">2</span>*<span class="hljs-title">a</span>))
}</code></pre>
<p>The compiler basically parses the expression, checks that every function called
returns a single value and then flattens the expression. So</p>
<pre><code class="language-plaintext hljs">    (<span class="hljs-number">3</span>*<span class="hljs-title">f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span> + <span class="hljs-number">2</span>))</code></pre>
<p>becomes</p>
<pre><code class="language-plaintext hljs">    <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> + <span class="hljs-title">f</span> *</code></pre>
<p>Inside expressions, you can return to normal Hop syntax with square brackets.
This is usually not that useful.</p>
<pre><code class="language-plaintext hljs">    (<span class="hljs-number">3</span>*<span class="hljs-title">f</span>(<span class="hljs-number">1</span>, [<span class="hljs-number">3</span> <span class="hljs-number">2</span> +]))</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allocations"><a class="header" href="#allocations">Allocations</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert-and-abort"><a class="header" href="#assert-and-abort"><code>assert</code> and <code>abort</code></a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Here are some small sample programs in Hop:</p>
<ol>
<li><a href="./guessing-game.html">Guessing Game</a></li>
<li><a href="./sorting.html">Sorting</a></li>
<li><a href="./strings.html">Strings</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guessing-game"><a class="header" href="#guessing-game">Guessing Game</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting"><a class="header" href="#sorting">Sorting</a></h1>
<p>Here is a Hop program that pushes 20 random <code>float</code>s onto a vector, sorts
the vector and prints the sorted <code>float</code>s:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">std</span>::<span class="hljs-title">vector</span>::{<span class="hljs-title">Vector</span>}
<span class="hljs-keyword">import</span> <span class="hljs-title">std</span>::<span class="hljs-title">vector</span>::{<span class="hljs-title">new_vector</span> <span class="hljs-title">free</span> <span class="hljs-title">push</span> <span class="hljs-title">pop</span> <span class="hljs-title">len</span> <span class="hljs-title">set</span> <span class="hljs-title">get</span>}
<span class="hljs-keyword">import</span> <span class="hljs-title">std</span>::<span class="hljs-title">prelude</span>::{<span class="hljs-title">swap</span> <span class="hljs-title">rot</span>}

<span class="hljs-keyword">fn</span> <span class="hljs-title">sort_vector</span> <span class="hljs-keyword">let</span> <span class="hljs-title">vector</span>: *<span class="hljs-title">Vector</span>[<span class="hljs-built_in">float</span>] {
    <span class="hljs-title">vector</span> <span class="hljs-title">len</span>
    <span class="hljs-keyword">let</span> <span class="hljs-title">len</span> {
        <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-title">len</span> {
            <span class="hljs-keyword">let</span> <span class="hljs-title">i</span> <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-title">len</span> <span class="hljs-title">swap</span> - <span class="hljs-number">1</span> - {
                <span class="hljs-keyword">if</span> (<span class="hljs-title">get</span>(<span class="hljs-title">vector</span>, <span class="hljs-title">i</span>) > <span class="hljs-title">get</span>(<span class="hljs-title">vector</span>, <span class="hljs-title">i</span> + <span class="hljs-number">1</span>)) {
                    <span class="hljs-title">vector</span> <span class="hljs-title">i</span> <span class="hljs-title">i</span> <span class="hljs-number">1</span> + <span class="hljs-title">swap_values</span>
                }
            }
        }
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">swap_values</span> <span class="hljs-keyword">let</span> <span class="hljs-title">vector</span>: *<span class="hljs-title">Vector</span>[<span class="hljs-built_in">float</span>] <span class="hljs-title">i</span>: <span class="hljs-built_in">int</span> <span class="hljs-title">j</span>: <span class="hljs-built_in">int</span> {
    <span class="hljs-title">vector</span> <span class="hljs-title">i</span> <span class="hljs-title">get</span>
    <span class="hljs-title">vector</span> <span class="hljs-title">i</span> <span class="hljs-title">vector</span> <span class="hljs-title">j</span> <span class="hljs-title">get</span> <span class="hljs-title">set</span>
    <span class="hljs-title">vector</span> <span class="hljs-title">j</span> <span class="hljs-title">rot</span> <span class="hljs-title">set</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-title">new_vector</span>[<span class="hljs-built_in">float</span>] <span class="hljs-keyword">call</span>
    <span class="hljs-keyword">let</span> <span class="hljs-title">_</span> <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">20</span> {
        @ <span class="hljs-title">random</span> <span class="hljs-title">push</span>
    }
    @ <span class="hljs-title">sort_vector</span>
    <span class="hljs-keyword">let</span> <span class="hljs-title">_</span> <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">20</span> {
        @ <span class="hljs-title">pop</span> <span class="hljs-title">putln</span>
    }
    <span class="hljs-title">free</span>
}</code></pre>
<p>When I ran this code, I got the following output:</p>
<pre><code class="language-shell">$ chop sorting.hop
$ clang -o out out.c
$ ./out
0.984995500650257
0.975773698184639
0.922811361029744
0.865170631557703
0.828553025610745
0.819387137424201
0.779078703373671
0.690552048850805
0.686372652184218
0.490707924123853
0.439625101163983
0.418656431138515
0.358641421422362
0.328084589913487
0.29020162159577
0.273296257480979
0.272030772641301
0.117705243639648
0.0211979113519192
0.0145168676972389
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Here is some sample code that demonstrates the standard library's
Unicode-capable <code>String</code> struct:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">import</span> <span class="hljs-title">std</span>::<span class="hljs-title">string</span>::{<span class="hljs-title">push</span> <span class="hljs-title">free</span> <span class="hljs-title">new_string</span> <span class="hljs-title">putln</span> <span class="hljs-title">pointer</span>}

<span class="hljs-keyword">global</span> <span class="hljs-title">EXPECTED</span>: *<span class="hljs-built_in">byte</span> { <span class="hljs-string">"abcങ𢄯Γx𢐎yz"</span> }

<span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> {
    <span class="hljs-title">new_string</span>
    @ <span class="hljs-string">'a'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'b'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'c'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'ങ'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'𢄯'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'Γ'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'x'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'𢐎'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'y'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-string">'z'</span> <span class="hljs-title">push</span>
    @ <span class="hljs-title">putln</span>                         <span class="hljs-comment">// print the string</span>
    @ <span class="hljs-title">pointer</span> <span class="hljs-title">EXPECTED</span> <span class="hljs-title">streq</span> <span class="hljs-keyword">assert</span> <span class="hljs-comment">// check that it's equal to the expected string</span>
    <span class="hljs-title">free</span>
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-note-on-transpilation"><a class="header" href="#a-note-on-transpilation">A Note on Transpilation</a></h1>
<p>Unlike Porth, the stack exists only at compile time. When the compiler emits
C code, all values are stored in variables. (Ironically, these values still live
on a stack. But the C code uses a <em>call</em> stack.) To see how this works, consider
the following program:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span> {
    <span class="hljs-literal">true</span>    <span class="hljs-comment">// stack is [bool]</span>
    <span class="hljs-number">1</span>       <span class="hljs-comment">// stack is [bool, int]</span>
    <span class="hljs-literal">false</span>   <span class="hljs-comment">// stack is [bool, int, bool]</span>
    <span class="hljs-title">putln</span>   <span class="hljs-comment">// stack is [bool, int]</span>
    <span class="hljs-title">put</span>     <span class="hljs-comment">// stack is [bool]</span>
    <span class="hljs-literal">true</span>    <span class="hljs-comment">// stack is [bool, bool]</span>
    ~ ~     <span class="hljs-comment">// stack is []</span>
}</code></pre>
<p>The compiler keeps track of the <em>maximum</em> number of values of each type on the
stack at any time. In this case, we have a maximum of 2 <code>bool</code>s and 1 <code>int</code>. So
the C code looks like this:</p>
<pre><code class="language-C">void func() {
    bool bool1, bool2;
    int int1;

    bool1 = true;
    int1 = 1;
    bool2 = false;
    putln(bool2);
    put(int2);
    bool2 = true;
}
</code></pre>
<p>As you can see, the compiler allocates enough variables to hold all the stack
values. Each time we push a value onto the stack, the compiler stores it in one
of the variables. We we push <code>true</code> in the first like of the function <code>func</code>,
it gets stored in the variable <code>bool1</code>. When we push <code>1</code>, it gets stored in
the variable <code>int1</code>. When we push <code>false</code>, the variable <code>bool1</code> is already in use,
so the values get stored in the variable <code>bool2</code>.</p>
<p>When generating C code, the compiler keeps track of a <em>variable</em> stack instead
of a <em>type</em> stack. The variable stack looks like this:</p>
<pre><code class="language-plaintext hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span> {
    <span class="hljs-literal">true</span>    <span class="hljs-comment">// stack is [bool1]</span>
    <span class="hljs-number">1</span>       <span class="hljs-comment">// stack is [bool1, int1]</span>
    <span class="hljs-literal">false</span>   <span class="hljs-comment">// stack is [bool1, int1, bool2]</span>
    <span class="hljs-title">putln</span>   <span class="hljs-comment">// stack is [bool1, int1]</span>
    <span class="hljs-title">put</span>     <span class="hljs-comment">// stack is [bool1]</span>
    <span class="hljs-literal">true</span>    <span class="hljs-comment">// stack is [bool1, bool2]</span>
    ~ ~     <span class="hljs-comment">// stack is []</span>
}</code></pre>
<p>When a function is called (let's use <code>putln</code> as an example), the compiler looks
at the stack and determines which variable to pass into the function. Before
the <code>putln</code> call, the variable stack is <code>[bool1, int1, bool2]</code>. The compiler
looks at the top of the stack and passes the variable <code>bool2</code> into the function
<code>putln</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
